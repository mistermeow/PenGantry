# -*- coding: utf-8 -*-
"""
Created on Sun May  2 13:00:34 2021

@author: dshneyer

@purpose: Creates a GUI that simulates an HMI. The state of the window is read every 100 milliseconds - simulating a PLC main routine. Events 
associated with clicking buttons on the GUI simulate interrupts. When in "RUN MODE" the program draws the four parts in 10mm incremenets. 
The user can click anywhere on the GUI and the program will report which part, if any, the clicked point is enclosed within. 
There are four system states:
    1. 'DRAWING' - The "controller" (Python runtime) draws each part in 10mm increments in order. Part 1 is drawn first, then 
        Part 2, then Part 3 and lastly Part 4. Parts cannot be drawn individually.
    2. 'RESET' - The "HMI" (the GUI) is cleared by closing and the window and reopening a new one. Each window must have a
        unique layout definition because of how PySimpleGUI creates windows, so the layout parameters are enclosed in a 
        "new_layout" function, called every time the RESET button is pressed.
    3. 'PAUSED' - The "controller" pauses its draw sequence at whatever point it was at when the Pause button was clicked.
        Drawing can be resumed from the point where it was left off by clicking the Start button.
    4. 'DRAWING COMPLETE' - This is the status displayed when all four parts have been fully drawn.
"""

import PySimpleGUI as sg # PySimpleGUI is used to create a virtual HMI interface on which the four parts are drawn in 10mm increments every 100 ms in order [Part 1, then 2, then 3, then 4]
from shapely.geometry import Point # The Point object is used to capture the coordinates of a mouse click event on the GUI
from shapely.geometry.polygon import Polygon # The Polygon object is leveraged to determine which part, if any, the location of a mouse click event on the GUI occurred within

corners = {
            'Part1': [(30, 700), (30, 850), (180, 850), (180, 700)],
            'Part2': [(650, 750), (650, 870), (750, 870), (750, 750)],
            'Part3': [(50, 20), (50, 120), (250, 120), (250, 20)],
            'Part4': [(500, 500), (500, 550), (700, 550), (700, 500)]
          } # Here I store the raw data provided for the corners of the parts in a dictionary
        
shapes = [
            Polygon(corners['Part1']),
            Polygon(corners['Part2']),
            Polygon(corners['Part3']),
            Polygon(corners['Part4']),
        ] # I will use the shapely module to check which of the four parts the returned mouse position was in during a click event

def new_layout(window_count): # Create the virtual HMI interfacce with user inputs buttons and controller + state feedback text objects
    layout = [      
               [sg.Graph(canvas_size=(1050, 1050), 
                    graph_bottom_left=(-25,-25), 
                    graph_top_right=(1025, 1025), 
                    key='-GRAPH-' + str(window_count),
                    change_submits=True, 
                    drag_submits=False)
                   ],      
               [sg.Text('CONTROLLER STATUS: OFF',size=(50, 1),justification='left', key='controller-state'),
                sg.Text('PROCESS STATE: RESET',size=(50, 1),justification='left', key='process-state')
               ],
               [sg.T('Commands:'), 
                   sg.Button('Start'),
                   sg.Button('Pause'),
                   sg.Button('Reset'),
                   sg.Text("Location of Click: "),
                   sg.Text(size=(100, 1),justification='left', key='mouse-click')
                   ]      
               ]  
    return layout
window_count = 0 # The Reset command works by closing the original window insteace and re-initializes a new one. Each instance must have a unique identifier, which this index is used to achieve.
layout = new_layout(window_count)

servo_step = 10 # Update HMI in 10mm increments - representing the servo step increment
coordinates = [] # List of points used to draw lines in 10mm incremenets that make up each part, in order
skip = [] # List of indices in the coordinates list above where the sequence jumps from the end of Part (n-1) to the beginning of Part n, so that lines don't get drawn between the parts
segment = 0 # Each part is comprised of four lines, referred to here as segments
for key, value in corners.items(): # The 10mm line increments are generated by interpolating between the four corner points
    while True:
        segment = segment + 1
        if segment == 1:
            for coordinate in range(corners[key][segment-1][1],corners[key][segment][1],servo_step):
                coordinates.append((corners[key][segment][0], coordinate))
        elif segment == 2:
            for coordinate in range(corners[key][segment-1][0],corners[key][segment][0],servo_step):
                coordinates.append((coordinate, corners[key][segment][1]))
        elif segment == 3:
            for coordinate in range(corners[key][segment-1][1],corners[key][segment][1],-servo_step):
                coordinates.append((corners[key][segment][0], coordinate))
        elif segment == 4:
            for coordinate in range(corners[key][segment-1][0],corners[key][0][0]-servo_step,-servo_step):
                coordinates.append((coordinate, corners[key][segment-1][1]))
        else:
            skip.append(len(coordinates) - 1) # The next line would be drawn between the last coordinate of the current part and the first coordinate of the next part
            segment = 0
            break

window = sg.Window('Pen Gantry', layout, finalize=True)  # Initialize the GUI 
graph = window['-GRAPH-' + str(window_count)]            # Initilize a graph object onto which lines and shapes can be drawn
graph.DrawRectangle((0,0),(1000,1000), line_color="red") # Draw the overall sheet from which the parts are to be cut
draw = False # When initialized and after Reset the state of the controller is STOPPED
while True:      
    event, values = window.read(timeout = 100) # Exit condition for the program once the GUI is closed. Window is updated every 100ms or on an event.    
    if event == sg.WIN_CLOSED: # If the GUI is closed, exit the program  
        break      
    
    mouse = values['-GRAPH-' + str(window_count)] # Save the mouse click location
    if event == '-GRAPH-' + str(window_count): # The moust click event
       if mouse == (None, None):
           continue
       point = Point(mouse[0], mouse[1]) # Get coordinates of mousse at time of click event; [0] is x coordinate, [1] is y coordinate
       for idx, part in enumerate(shapes): # Each part is defined as a polygon and stored in a list
           if part.contains(point): # If mouse location is contained within a part report the coordinates and part number on the GUI
               stsPartSelected = "(" + str(mouse[0]).strip() + "," + str(mouse[1]).strip() + ") is contained within the area of Part" + str(idx+1)
               window['mouse-click'].update(stsPartSelected)
               break
           elif idx+1 == len(shapes):
               stsPartSelected = None
               window['mouse-click'].update("(" + str(mouse[0]).strip() + "," + str(mouse[1]).strip() + ") is not contained within the area of any known Part")
    
    if event == 'Pause': # Push the Pause button to abort the current drawing operation
        window['controller-state'].update('CONTROLLER STATUS: OFF')
        window['process-state'].update('PROCESS STATE: PAUSED')
        draw = False
       
    if event == 'Reset': # Push the Reset button to reset the program. Resetting also "homes" in this program.
        window['controller-state'].update('CONTROLLER STATUS: OFF')
        window['process-state'].update('PROCESS STATE: RESET')
        window_count += 1
        window.close() # Clear the GUI by closing and the reopening the window
        window = sg.Window('Pen Gantry', new_layout(window_count), finalize=True) #Initialize the new window
        graph = window['-GRAPH-' + str(window_count)]  
        graph.DrawRectangle((0,0),(1000,1000), line_color="red") # Draw the overall sheet from which the parts are to be cut
        segment = 0 # Reset the drawing sequence counter to zero
        draw = False
    
    if event == 'Start':  # Push the Start button to start or continue the drawing sequence
        window['controller-state'].update('CONTROLLER STATUS: RUN')
        window['process-state'].update('PROCESS STATE: DRAWING')
        draw = True
        
    if draw == True and event == sg.TIMEOUT_KEY: # Draw lines if the controller is in RUN state AND no other events have occurred
        if segment < len(coordinates) - 1: # len function is 1 indexed but number of items actually in list is 0 indexed
            if segment not in skip: # Skip segments that would draw between the end point of a part and the start point of the next part 
                graph.DrawLine(coordinates[segment], coordinates[segment+1]) # All shapes drawn sequentially, one line segment at a time. Cannot redraw without resetting whole process 
                segment += 1
            else:
                segment += 1
                if skip.index(segment - 1) == 0:
                    graph.DrawText("Part 1",(R100,775))
                elif skip.index(segment - 1) == 1:
                    graph.DrawText("Part 2",(700,820))
                elif skip.index(segment - 1) == 2:
                    graph.DrawText("Part 3",(150,60))
        else:
            window['process-state'].update('PROCESS STATE: DRAWING COMPLETE')
            graph.DrawText("Part 4",(600,525))